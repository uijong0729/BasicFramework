1.DBMS를 사용하는 이유
	비즈니스 로직 실행 결과 = 데이터
	일관성 : 데이터가 같은 것
	무결성 : 데이터의 규칙이 같은 것
	영속성 : 시스템이 다시 시작할 때 데이터가 같은 것
	
2.일관성과 무결성을 위해 DBMS가 제공하는 기능
	트랜잭션
		한 개 이상의 SQL이 논리적으로 묶인 단위
		ACID(원자성) : 트랜잭션이 가져야 할 조건
		LDIC : 트랜잭션 직렬성을 위해 하지말아야 할 조건
			- Lost Update 
			- Dirty Read
			- Inconsistency
			- Cascading roll-back
		MVCC : 로그 선행 기록(WAL), 조회 성능 향상
			- WAL : WAL을 사용하는 시스템에서 모든 수정은 적용 이전에 로그에 기록된다.
	SQL
		DML : CRUD
		DCL : commit, roll-back, revoke 등
		DDL : create table, create datafile

3.비즈니스 로직에 필요한 DBMS기능
	트랜잭션
		Connection 객체
		commit, roll-back
	SQL
		SQL실행 : CRUD
		SQL결과 : table 또는 int
		
4.SQL의존문제를 해결합니다.
	SQL의존문제
		SQL기능과 비즈니스 로직이 복잡하게 섞여있는 문제 -> 유지보수 비용 발생
			트랜잭션 : Connection 객체관리, commit/roll-back을 명확히 해주지 못함
			SQL실행 : 자바코드로 작성된 동적/정적 SQL실행
			SQL결과 : 결과를 취득시 비용 (VO, DTO, get, set 메소드의 남용)

5.프레임워크가 구현할 기능 - 트랜잭션
	시작 -> 활동 -> 성공 -> 부분완료 -> 커밋 -> 완료
	시작 -> 활동 -> 성공 -> 부분완료 -> 오류 -> 실패 -> 롤백 -> 철회
	시작 -> 활동 -> 오류 -> 실패 -> 롤백 -> 철회 
	
	오류의 원인
		클라이어트 비정상종료
		DBMS다운
		DCL(roll-back)
	
	conn.setAutoCommit(false) -> conn.commit()
	conn.setAutoCommit(false) -> conn.rollback()
	
6.프레임워크가 구현할 기능 - SQL
	CRUD SQL과 java코드의 분리
		KEY = SQL
		FW_SQL TABLE
	정적 SQL의 성능과 동적 SQL 유연성 제공
		- 정적 SQL : 미리 SQL을 준비하고 바인드 변수를 넘겨 실행
		- 동적 SQL : 하나의 String객체에 SQL을 작성하고 바로 실행
	SQL결과
		SELECT 결과 : TABLE
		INSERT / UPDATE / DELETE 결과 : int
		VO같은 경우는 높은 내용 결합도를 유발하므로 유지보수가 어려워져 사용 하지 않음
			- VO(Value object) : 비즈니스를 수행하는데 필요한 데이터의 집합, 이름, 타입, 다른 데이터간 관계를 표현하기위한 기법
			- 내용결합도 : 호출하여 사용하려는 모듈의 내용을 알고있지 않으면 사용하기 어려움
			- VO의 문제점
				Super VO : 지속적인 기능추가에 따른 관습적인 구현 (메소드 수, 멤버변수 수가 계속 증가)
				블랙박스 : 실행시점에서 오류 발생
				개발비용증가 : 데이터 타입 추가시 관련 모듈의 수정이 필요함
			- VO의 대안
				기본 Collection의 사용 : toString재구현, key Class사용
				Collection의 가공 : Box구현

7.SQL의존문제를 해결합니다.
	SQL의존문제 : SQL기능과 비즈니스 로직이 복잡하게 섞여있는 문제
	SQL기능
		- 트랜잭션 : Transaction.java
		- SQL실행 : SqlRunner.java
		- SQL결과 : Table.java
	
	